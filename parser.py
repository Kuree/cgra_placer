from __future__ import print_function
import sys
import json
import os
import networkx as nx


def parse_netlist(netlist_filename):
    """parse the netlist. also perform simple "packing" while reading out
       connections.
    """
    assert(os.path.isfile(netlist_filename))
    with open(netlist_filename) as f:
        raw_data = json.load(f)
    namespace = raw_data["namespaces"]
    design = namespace["global"]["modules"]["DesignTop"]
    instances = design["instances"]
    connections = design["connections"]
    name_to_id = {}
    id_count = 0
    # don't care list
    dont_care = set()
    for name in instances:
        attrs = instances[name]
        if "genref" not in attrs:
            assert("modref" in attrs)
            assert(attrs["modref"] == u"corebit.const")
            dont_care.add(name)
            continue
        instance_type = attrs["genref"]
        if instance_type == "cgralib.PE":
            blk_type = "p"
        elif instance_type == "cgralib.IO":
            blk_type = "i"
        elif instance_type == "cgralib.Mem":
            blk_type = "m"
        elif instance_type == "coreir.const":
            dont_care.add(name)
            continue
        elif instance_type == "coreir.reg":
            dont_care.add(name)
            continue
        else:
            raise Exception("Unknown instance type", instance_type)
        blk_id = blk_type + str(id_count)
        id_count += 1
        name_to_id[name] = blk_id
    # read the connections and pack them
    g = nx.Graph()
    netlists = {}
    # hyper edge count
    h_edge_count = 0
    for conn in connections:
        edge_id = "e" + str(h_edge_count)
        h_edge_count += 1
        hyper_edge = []
        for v in conn:
            blk_name = v.split(".")[0]
            if blk_name not in name_to_id and blk_name not in dont_care:
                raise Exception("cannot find", blk_name, "in instances")
            if blk_name in name_to_id:
                blk_id = name_to_id[blk_name]
                g.add_edge(edge_id, blk_id)
                hyper_edge.append(blk_id)
        netlists[edge_id] = hyper_edge
    for edge in g.edges():
        g[edge[0]][edge[1]]['weight'] = 1
    g = g.to_undirected()
    # reverse it since we need the actual name for placement
    id_to_name = {}
    for b_id in name_to_id:
        id_to_name[name_to_id[b_id]] = b_id

    return netlists, g, dont_care, id_to_name


# parse the ones generated by metapath2vec
def parse_emb(filename, filter_hyperedge=True, filter_complex=False):
    with open(filename) as f:
        lines = f.readlines()
    lines = lines[2:]
    input_data = {}
    num_dim = 0
    for line in lines:
        raw_data = line.split()
        if num_dim == 0:
            num_dim = len(raw_data) - 1
        else:
            assert(len(raw_data) == num_dim + 1)
        netid = raw_data[0]
        if filter_hyperedge and netid[0] == "e":
            continue
        if filter_complex and netid[0] != "c":
            continue
        inputs = [float(x) for x in raw_data[1:]]
        input_data[netid] = inputs
    return num_dim, input_data


# test
if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage:", sys.argv[0], "<netlist_filename>", file=sys.stderr)
        exit(1)
    print(len(parse_netlist(sys.argv[1])))
